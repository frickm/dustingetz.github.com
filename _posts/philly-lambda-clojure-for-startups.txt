lambda notes - 12 march 2012

sponsored by - Comcast Interactive Media, they're hiring - cimlife.com - sr level developers - people who like programming

Paul deGrandis
- worked briefly at CIM
- back from east coast - lives in NYC now
- talk for clojure/west on march 16

after talk, two projects using clojure - 
- how to build a static analyser for a functiona, dynamic language - which is hard for lisps because you can redefine the whole lang
- doing for clojure w core.logic to reason aobut programs. logic programming (like prolog) - paul is new to this. ex problem: "how do i optimize calendars?" show a practical use for logic programming

- "baking websites is fucking badass" - "bake" ?? completely because its secure
- serve static page but make remote calls etc, demo of this? i missed what he said here

Paul is VP Egr at tutorspreea, who is also hiring

clojure adoption and clojure success. if its on the rise, where are the success stories, whats the best way to apply clojure?

Niel Ford talk at Conj last autumn - master plan for enterprise domination. laid out strategies
takeaways - how enterprise software development works? Neil ford is the master of this area

Paul - im not in a large enterprise software thing, working withs tartups. largest team 10 people, mostly 5 people. split in small teams. so Paul has freedom to choose. Neil points don't matter as much.

people using clojure, e.g. CIM, what techniques can we use to get success? mine the success stories, distill them into one toolbox 

NF: CTOs are drivin by fear, make decisions worried about making the wrong decisions. evaluate risk, unknowns, failure changes. Risk driven. true of large enterprises, true for startups. we make decisions for evaluation risk. in order to do this, need objective data, rapid adaptation - so i can instantly realize what is wrong, i need tools that allow me to see and switch real fast. spiral iteration. risk driven architectures. want to take the unknowns, how can we find more info about them, navigate the space as flexible as we possibly can. success is - winnning at the risks, beating the odds.

"Clojure manages risk better than any other technologies" - he asserts that this is true. if this is true, this is our tagline. "Ill show you four cases touse clojure to manage risk better than you aare now " - this is the killer argument for clojure adoption.
"seeking a success protocol" steps we need to do

multimethod - how to be successful with clojure in an enterprise - NF.
1. prototype - get lots of eyes on clojure. increased awareness for everybody.
2. toolchain - lots of points of contacts with lcojure. they don't have to understand, but we want them touching it
3. crux - solbing the hardest part we can with clojure - lots of minds.

these three things are clojure. if you can do these you win, by manaing risk better than other tech

1. prototyping:
maximize awareness
demonstrate value
allow others to "hold"

two possible soltuons to this problem, heres the research, here's the impl. "you solved an unknown, w/ clojure, in one week"

2. toolchain -
Pushbutton Labs - built a compiler for this language to script his video game, and got it onto all the customers of the games. now 

what are the reasons this was making him personally more productive?
- web layer at tutorspree (php) - small, who cares
- reranking search order

--- adapt quickly. need machine learning. statistical problem. deliver as fast as i can to look at data. to iterate on hard problem - how to detect learning styles.

Q: clojrue v python, why is clojure so muc better?
clojure as a community, toolset, language - forces you to be bottom up. build on the smallest nugget, building blocks, that you can build with. a bucket of legos. (he implies this is something that python is less good at). after you stimulate team usage, team picks up, groks it. biggest risk - can i get enough talent, and can i teach my team how to program in clojure effectively? Case stides World Singles - Sean COrfield (a clojure contributor)  he used coldfusion before, switched to clojure. risk: we have to switch platforms, CF s dead, how towe do it?

so if we can sell them on so easy, they're going to adopt it naturally. just need that first hump. get stuck in the feedback hump on Crux slide which is great - start kicking ass - "kick ass circle" haha. (ed zone baby) clojure lets you hit thiz zone better than any other technology.

culture surrounding clojure and that community - don't need a huge team, need a small team. a pro, and someone taking legos . but need a lego factory. taking about surgical team per fred brooks MMM - 

community is infectious - winning product needs winning team - winning team needs winning culture (attract great team), then product comes for free. 

clojure forces you to think problems in a bottom up way. build legos to solve his learning problem - in other langages, you have to actively try harder to do this. other startp collective intelligence problem. he did it in python, extremely funtional python - but he had to try real hard, had 

Paul seems to be speaking from the perspective of maximizing clojure adoption, not why clojure.


opinions of the language - functional style.

Ben - what is the absolutely necessary stuff - if i cut the size of clojure in half, what do you keep. is it the mutabulity? concurrency? macros? Paul - comes down to few key things - 1. datastructures implemented. python: write a reduce that grows a collection. python reduce that appends to collection - copy arrays. datastructures just aren't designed to solve real hard problems. you could do that in java but its not batteries included. Functional Java language thing - hacks to short circuit reflection, allow you to do reduce, etc. Paul - doesnt know, .. references art of metaobject protocol - that author she is creator of aspect oriented programmiing? huh. \

"building a team using clojure was scariest thing ive ever done, borderline irrisponsile". only risk is getting tyhe team to use clojure.
ben - in terms of compelling features - 1. immutable datastructures, (sane mutability, better said functional datastructures - 


"i dont write haskell for performance" - 

ben is saying, clojure is not the only conceivable language to do this. 1. first class functions, 2. sane mutability. 3. 

nick c - trying to get a lot of hands on haskell can be a problem.

Paul - comes down to "our culture" - Dan M - haskell was very academicy things in our brain. SPJ - says its supposed to have a trickle down effect to other languages. haskel - first language to study monads, they have trickled into clojure now. 

super functional python - start bending the language in a way that hte language doesn't like, and the community hates it.

HH - we're on jvm, CLR sooner or later, and javscript which is maturing - 

[Trev - jruby is one of the fastest impl of ruby. hh is it true of jython? dunno. pypy]


Paul. are we really winning? adoption, %growth of jobs is rocketing up. manages risk really well.

we questioned his graph of clojure % growth.

why is clojure more popular than scala? big theme at clojure con - "stop fighting scala". 1. want to get as fasr away from java s i can, the toolkit and mindset isn't what i want - really dig into functional scala and convince team as well. "what level of scala programmer are you" "noob level - you don't use oo features. 2. you know how to do reduce and foldl" haha. 

clojure has nifty features to make things persistant
clojure wrapping lbiraries discussion. wrapping war

"language matches my style of problem solving"
- 

hh: interactive development.

factor - a language that isn't a lisp, not a paren language, smalltalk - adanced interactive development environments. super interactive languages - smalltalk. leverages 30 years of lispers doing interactive development. lego analogy. not going at the problem head on. lego building happens interactively.

DM: languages rooted in lambda calculus are better at decomposing problems. dustin said something stupid about haskell and got headshakes from kyle. about using type system to build legos interactively instead of using the interactive emacs.

thems:clojures opinions are what i find attractive.
problem domain and language domain. interactive development.

trev: clojure matches your thought process, but how does your thought process work?
feedback: transitioning from java - java devs afraid of functional.

martin: didn't use clojure for his web layer - very thin - firs stuff to rabit mq - easiest way to manage risk is to hire cheap developers. kyle  -the libraries for clojure are not mature, so uses rails for web layer. ring - crappy error handling. this is a negative aspect of the community. kyle - community emphasizes core clojrue community valus - lead you to writing cde that doesn't have to be debugged. paul - 3 versons of tutorspree, third is in clojure in web layer.


matin: why did it take so long for this to happeb? history of FP and lisps in general:
lisp machines - first time raw performance died, because commodity computer won. "inferior tech won". cl could have won, but it got so close to AI.;

OO - paradigms change with the level of complexity - procedural to non -o, non-p to OO. had a hard time using a different type of abstraction. now bigdata and concurrency. stream processing, sequence. Guis. managing objects in an environment - this is OO. sort of difficult to do functional. i"nonsense". fp is about applying manipulations on data, a gui doesn't . web request from response DOES map well.

collective intelligence problem in a web framewrok - super functional python. wow, the way im solving every problem is this way. the abstractions you arrive at other people independently arrived at.

nck c- surgical team metaphor

baked, clojurescript, importance of forms, designer lorem text on client with code to do transforms on the client
